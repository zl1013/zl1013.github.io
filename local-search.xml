<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux下Zookeeper安装</title>
    <link href="/2020/08/10/Linux%E4%B8%8BZookeeper%E5%AE%89%E8%A3%85/"/>
    <url>/2020/08/10/Linux%E4%B8%8BZookeeper%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="ZOOKEEPER安装部署"><a href="#ZOOKEEPER安装部署" class="headerlink" title="ZOOKEEPER安装部署"></a>ZOOKEEPER安装部署</h1><h3 id="1-准备安装包"><a href="#1-准备安装包" class="headerlink" title="1. 准备安装包"></a>1. 准备安装包</h3><p>这⾥使⽤的是 <code>3.6.1</code> 版，下载的是 <code>apache-zookeeper-3.6.1-bin.tar.gz</code> 压缩包，并将其放在了 <code>/root</code> ⽬录下</p><h3 id="2-解压并安装"><a href="#2-解压并安装" class="headerlink" title="2. 解压并安装"></a>2. 解压并安装</h3><ul><li>在 <code>/usr/local/</code> 下创建 <code>zookeeper</code> ⽂件夹并进⼊</li></ul><pre><code class="hljs shell">cd /usr/local/mkdir zookeepercd zookeeper</code></pre><ul><li>将 <code>ZooKeeper</code> 安装包解压到  <code>/usr/local/zookeeper</code> 中即可</li></ul><pre><code class="hljs shell">[root@iZbp19oigcst5l5m3e6pdfZ zookeeper]# tar -zxvf /root/apache-zookeeper-3.6.1-bin.tar.gz -C ./</code></pre><h3 id="3-创建DATA⽬录"><a href="#3-创建DATA⽬录" class="headerlink" title="3. 创建DATA⽬录"></a>3. 创建DATA⽬录</h3><p>这⾥直接在 <code>/usr/local/zookeeper/apache-zookeeper-3.6.1-bin</code> ⽬录中创建⼀个 <code>data</code> ⽬录</p><p><img src="https://gitee.com/zzl_java/PicGo/raw/master/img/20200815190426.png" srcset="/img/loading.gif" alt="image-20200815190426864"></p><p>等下该 <code>data</code> ⽬录地址要配到 <code>ZooKeeper</code> 的配置⽂件中：</p><h3 id="4-创建配置⽂件并修改"><a href="#4-创建配置⽂件并修改" class="headerlink" title="4. 创建配置⽂件并修改"></a>4. 创建配置⽂件并修改</h3><p>进⼊到 <code>zookeeper</code> 的 <code>conf</code> ⽬录，复制 <code>zoo_sample.cfg</code> 得到 <code>zoo.cfg</code> ：</p><pre><code class="hljs shell">[root@iZbp19oigcst5l5m3e6pdfZ apache-zookeeper-3.6.1-bin]# cd conf/[root@iZbp19oigcst5l5m3e6pdfZ conf]# cp zoo_sample.cfg zoo.cfg</code></pre><p>修改配置⽂件 <code>zoo.cfg</code> ，将其中的 <code>dataDir</code> 修改为上⾯刚创建的 <code>data</code> ⽬录，其他选项可以按需配置</p><p><img src="https://gitee.com/zzl_java/PicGo/raw/master/img/20200815191038.png" srcset="/img/loading.gif" alt="image-20200815191038266"></p><h3 id="5-启动ZOOKEEPER"><a href="#5-启动ZOOKEEPER" class="headerlink" title="5. 启动ZOOKEEPER"></a>5. 启动ZOOKEEPER</h3><pre><code class="hljs shell">[root@iZbp19oigcst5l5m3e6pdfZ apache-zookeeper-3.6.1-bin]# ./bin/zkServer.sh start</code></pre><p><img src="https://gitee.com/zzl_java/PicGo/raw/master/img/20200815191259.png" srcset="/img/loading.gif" alt="image-20200815191259966"></p><p>启动后可以通过如下命令来检查启动后的状态：</p><pre><code class="hljs shell">[root@iZbp19oigcst5l5m3e6pdfZ apache-zookeeper-3.6.1-bin]# ./bin/zkServer.sh status</code></pre><p><img src="https://gitee.com/zzl_java/PicGo/raw/master/img/20200815191436.png" srcset="/img/loading.gif" alt="image-20200815191436920"></p><p>从图中也可以看出zookeeper默认会绑定端⼝ <code>2181</code></p><h3 id="6-配置环境变量"><a href="#6-配置环境变量" class="headerlink" title="6. 配置环境变量"></a>6. 配置环境变量</h3><p>编辑配置⽂件：</p><pre><code class="hljs shell">vim /etc/profile</code></pre><p>尾部加⼊<code>ZooKeeper</code> 的 <code>bin</code> 路径配置即可</p><pre><code class="hljs properties"><span class="hljs-attr">export</span> <span class="hljs-string">ZOOKEEPER_HOME=/usr/local/zookeeper/apache-zookeeper-3.6.1-bin</span><span class="hljs-attr">export</span> <span class="hljs-string">PATH=$PATH:$ZOOKEEPER_HOME/bin</span></code></pre><p>最后执⾏<code>source /etc/profile</code> 使环境变量⽣效即可</p><h3 id="7-设置开机⾃启"><a href="#7-设置开机⾃启" class="headerlink" title="7. 设置开机⾃启"></a>7. 设置开机⾃启</h3><p>⾸先进⼊ <code>/etc/rc.d/init.d</code> ⽬录，创建⼀个名为 <code>zookeeper</code> 的⽂件，并赋予执⾏权限</p><pre><code class="hljs shell">[root@iZbp19oigcst5l5m3e6pdfZ apache-zookeeper-3.6.1-bin]# cd /etc/rc.d/init.d/[root@iZbp19oigcst5l5m3e6pdfZ init.d]# touch zookeeper[root@iZbp19oigcst5l5m3e6pdfZ init.d]# chmod +x zookeeper</code></pre><p>接下来编辑 <code>zookeeper</code> ⽂件，并在其中加⼊如下内容：</p><pre><code class="hljs properties"><span class="hljs-comment">#!/bin/bash</span><span class="hljs-comment">#chkconfig:- 20 90</span><span class="hljs-comment">#description:zookeeper</span><span class="hljs-comment">#processname:zookeeper</span><span class="hljs-attr">ZOOKEEPER_HOME</span>=<span class="hljs-string">/usr/local/zookeeper/apache-zookeeper-3.6.1-bin</span><span class="hljs-attr">export</span> <span class="hljs-string">JAVA_HOME=/usr/local/java/jdk1.8.0_261 # 此处根据你的实际情况更换对应</span><span class="hljs-attr">case</span> <span class="hljs-string">$1 in</span> <span class="hljs-meta">start)</span> <span class="hljs-string">su root $ZOOKEEPER_HOME/bin/zkServer.sh start;;</span> <span class="hljs-meta">stop)</span> <span class="hljs-string">su root $ZOOKEEPER_HOME/bin/zkServer.sh stop;;</span> <span class="hljs-meta">status)</span> <span class="hljs-string">su root $ZOOKEEPER_HOME/bin/zkServer.sh status;;</span> <span class="hljs-meta">restart)</span> <span class="hljs-string">su root $ZOOKEEPER_HOME/bin/zkServer.sh restart;;</span> <span class="hljs-meta">*)</span> <span class="hljs-string">echo "require start|stop|status|restart" ;;</span><span class="hljs-attr">esac</span></code></pre><p>最后加⼊开机启动即可：</p><pre><code class="hljs shell">chkconfig --add zookeeperchkconfig zookeeper on</code></pre><p>如果系统⾃带有 <code>OpenJDK</code> ，可以按照如下步骤提前卸载之。</p><p>⾸先查找已经安装的 <code>OpenJDK</code> 包：</p><pre><code class="hljs shell">rpm -qa | grep java</code></pre><p>如果有就将 java 开头的安装包均卸载即可:</p><pre><code class="hljs shell">yum -y remove java-1.7.0-openjdk-1.7.0.141-2.6.10.5.el7.x86_64yum -y remove java-1.8.0-openjdk-1.8.0.131-11.b12.el7.x86_64... 省略 ...</code></pre><p>我这里没有，就可以直接下一步</p><pre><code class="hljs shell">[root@iZbp19oigcst5l5m3e6pdfZ ~]# rpm -qa | grep java[root@iZbp19oigcst5l5m3e6pdfZ ~]#</code></pre><h3 id="2-创建⽬录并解压"><a href="#2-创建⽬录并解压" class="headerlink" title="2. 创建⽬录并解压"></a>2. 创建⽬录并解压</h3><p>1、在<code>/usr/local/</code> 下创建 <code>java</code> ⽂件夹并进⼊</p><pre><code class="hljs shell">cd /usr/local/mkdir javacd java</code></pre><ol start="2"><li>将上⾯准备好的 JDK 安装包解压到 <code>/usr/local/java</code> 中即可</li></ol><pre><code class="hljs shell">tar -zxvf /root/jdk-8u261-linux-x64.tar.gz -C ./</code></pre><p>解压完之后，<code>/usr/local/java</code> ⽬录中会出现⼀个 <code>jdk1.8.0_261</code> 的⽬录</p><h3 id="3-配置JDK环境变量"><a href="#3-配置JDK环境变量" class="headerlink" title="3. 配置JDK环境变量"></a>3. 配置JDK环境变量</h3><p>编辑 <code>/etc/profile</code> ⽂件，在⽂件尾部加⼊如下 <code>JDK</code> 环境配置即可</p><pre><code class="hljs shell">JAVA_HOME=/usr/local/java/jdk1.8.0_261CLASSPATH=$JAVA_HOME/lib/PATH=$PATH:$JAVA_HOME/binexport PATH JAVA_HOME CLASSPATH</code></pre><p>然后执⾏如下命令让环境变量⽣效</p><pre><code class="hljs shell">source /etc/profile</code></pre><h3 id="4-验证JDK安装结果"><a href="#4-验证JDK安装结果" class="headerlink" title="4. 验证JDK安装结果"></a>4. 验证JDK安装结果</h3><p>输⼊如下命令即可检查安装结果：</p><pre><code class="hljs shell">java -versionjavac</code></pre><p><img src="https://gitee.com/zzl_java/PicGo/raw/master/img/20200815135617.png" srcset="/img/loading.gif" alt="image-20200815135617909"></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot接收多个参数(Get)</title>
    <link href="/2020/08/08/SpringBoot%E6%8E%A5%E6%94%B6%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0(Post)/"/>
    <url>/2020/08/08/SpringBoot%E6%8E%A5%E6%94%B6%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0(Post)/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot接收多个参数-Post"><a href="#SpringBoot接收多个参数-Post" class="headerlink" title="SpringBoot接收多个参数(Post)"></a>SpringBoot接收多个参数(Post)</h1><h2 id="Post方法"><a href="#Post方法" class="headerlink" title="Post方法"></a>Post方法</h2><p>下面演示如何接收通过 POST 方式传递过来的参数</p><h3 id="1-接收-Form-表单数据"><a href="#1-接收-Form-表单数据" class="headerlink" title="1. 接收 Form 表单数据"></a>1. 接收 Form 表单数据</h3><ol><li>基本的接收方法</li></ol><ul><li>下面样例 Controller 接收 form-data 格式的 POST 数据：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"name"</span>)</span> String name,</span><span class="hljs-function">                        @<span class="hljs-title">RequestParam</span><span class="hljs-params">(<span class="hljs-string">"age"</span>)</span> Integer age) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"name："</span> + name + <span class="hljs-string">"\nage："</span> + age;    &#125;&#125;</code></pre><ol start="2"><li>参数没有传递的情况</li></ol><ul><li><p>如果没有传递参数 Controller 将会报错，这个同样有如下两种解决办法：</p><ul><li><p>使用 required = false 标注参数是非必须的</p></li><li><p>使用 defaultValue 给参数指定个默认值</p></li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@RequestParam(name = <span class="hljs-string">"name"</span>, defaultValue = <span class="hljs-string">"xxx"</span>)</span> String name,</span><span class="hljs-function">                        @<span class="hljs-title">RequestParam</span><span class="hljs-params">(name = <span class="hljs-string">"age"</span>, required = <span class="hljs-keyword">false</span>)</span> Integer age) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"name："</span> + name + <span class="hljs-string">"\nage："</span> + age;    &#125;&#125;</code></pre><ol start="3"><li>使用 map 来接收参数</li></ol><ul><li>Controller 还可以直接使用 map 来接收所有的请求参数：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController; <span class="hljs-keyword">import</span> java.util.Map; <span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@RequestParam Map&lt;String,Object&gt; params)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"name："</span> + params.get(<span class="hljs-string">"name"</span>) + <span class="hljs-string">"\nage："</span> + params.get(<span class="hljs-string">"age"</span>);    &#125;&#125;</code></pre><ol start="4"><li>接收一个数组</li></ol><ul><li>表单中有多个同名参数，Controller 这边可以定义一个数据进行接收：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController; <span class="hljs-keyword">import</span> java.util.Map; <span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"name"</span>)</span> String[] names) </span>&#123;        String result = <span class="hljs-string">""</span>;        <span class="hljs-keyword">for</span>(String name:names)&#123;            result += name + <span class="hljs-string">"\n"</span>;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><ol start="5"><li>使用对象来接收参数</li></ol><ul><li>如果一个 <strong>post</strong> 请求的参数太多，我们构造一个对象来简化参数的接收方式：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(User user)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"name："</span> + user.getName() + <span class="hljs-string">"\nage："</span> + user.getAge();    &#125;&#125;</code></pre><ul><li>User 类的定义如下，到时可以直接将多个参数通过 getter、setter 方法注入到对象中去：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;         <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;&#125;</code></pre><ul><li>如果传递的参数有前缀，且前缀与接收实体类的名称相同，那么参数也是可以正常传递的：</li><li>如果一个 get 请求的参数分属不同的对象，也可以使用多个对象来接收参数：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(User user, Phone phone)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"name："</span> + user.getName() + <span class="hljs-string">"\nage："</span> + user.getAge()                + <span class="hljs-string">"\nnumber："</span> + phone.getNumber();    &#125;&#125;</code></pre><ol start="6"><li>使用对象接收时指定参数前缀</li></ol><ul><li><p>如果传递的参数有前缀，且前缀与接收实体类的名称不同相，那么参数无法正常传递：</p></li><li><p>我们可以结合 @InitBinder 解决这个问题，通过参数预处理来指定使用的前缀为 u.</p><p>  <code>除了在 Controller 里单独定义预处理方法外，我们还可以通过 @ControllerAdvice 结合 @InitBinder 来定义全局的参数预处理方法，方便各个 Controller 使用</code></p></li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">import</span> org.springframework.web.bind.WebDataBinder;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*; <span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@ModelAttribute(<span class="hljs-string">"u"</span>)</span> User user) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"name："</span> + user.getName() + <span class="hljs-string">"\nage："</span> + user.getAge();    &#125;     <span class="hljs-meta">@InitBinder</span>(<span class="hljs-string">"u"</span>)    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initBinder</span><span class="hljs-params">(WebDataBinder binder)</span> </span>&#123;        binder.setFieldDefaultPrefix(<span class="hljs-string">"u."</span>);    &#125;&#125;</code></pre><h3 id="2-接收字符串文本数据"><a href="#2-接收字符串文本数据" class="headerlink" title="2. 接收字符串文本数据"></a>2. 接收字符串文本数据</h3><ul><li>如果传递过来的是 Text 文本，我们可以通过 HttpServletRequest 获取输入流从而读取文本内容。</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController; <span class="hljs-keyword">import</span> javax.servlet.ServletInputStream;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> java.io.IOException; <span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        ServletInputStream is = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            is = request.getInputStream();            StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();            <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];            <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> ((len = is.read(buf)) != -<span class="hljs-number">1</span>) &#123;                sb.append(<span class="hljs-keyword">new</span> String(buf, <span class="hljs-number">0</span>, len));            &#125;            System.out.println(sb.toString());            <span class="hljs-keyword">return</span> <span class="hljs-string">"获取到的文本内容为："</span> + sb.toString();        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (is != <span class="hljs-keyword">null</span>) &#123;                    is.close();                &#125;            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><h3 id="3-接收-JSON-数据"><a href="#3-接收-JSON-数据" class="headerlink" title="3. 接收 JSON 数据"></a>3. 接收 JSON 数据</h3><ol><li>使用 Map 来接收数据</li></ol><ul><li>如果把 json 作为参数传递，我们可以使用 @requestbody 接收参数，将数据转换 Map：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestBody;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController; <span class="hljs-keyword">import</span> java.util.Map; <span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@RequestBody Map params)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"name："</span> + params.get(<span class="hljs-string">"name"</span>) + <span class="hljs-string">"\n age："</span> + params.get(<span class="hljs-string">"age"</span>);    &#125;&#125;</code></pre><ol start="2"><li>使用 Bean 对象来接收数据</li></ol><ul><li>如果把 json 作为参数传递，我们可以使用 @requestbody 接收参数，将数据直接转换成对象：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestBody;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController; <span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@RequestBody User user)</span></span>&#123;        <span class="hljs-keyword">return</span> user.getName() + <span class="hljs-string">" "</span> + user.getAge();    &#125;&#125;</code></pre><ul><li>User 类定义如下：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;&#125;</code></pre><ol start="4"><li>如果传递的 JOSN 数据是一个数组也是可以的，Controller 做如下修改：</li></ol><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestBody;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController; <span class="hljs-keyword">import</span> java.util.List; <span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@RequestBody List&lt;User&gt; users)</span></span>&#123;        String result = <span class="hljs-string">""</span>;        <span class="hljs-keyword">for</span>(User user:users)&#123;            result += user.getName() + <span class="hljs-string">" "</span> + user.getAge() + <span class="hljs-string">"\n"</span>;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Post</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot接收多个参数(Get)</title>
    <link href="/2020/08/08/SpringBoot%E6%8E%A5%E6%94%B6%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0(Get)/"/>
    <url>/2020/08/08/SpringBoot%E6%8E%A5%E6%94%B6%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0(Get)/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot接收多个参数-Get"><a href="#SpringBoot接收多个参数-Get" class="headerlink" title="SpringBoot接收多个参数(Get)"></a>SpringBoot接收多个参数(Get)</h1><h2 id="Get方法"><a href="#Get方法" class="headerlink" title="Get方法"></a>Get方法</h2><p>利用 <strong>Spring Boot</strong> 来制作 <strong>Web</strong> 应用，就必定会涉及到前端与后台之间互相传递参数。下面演示 <strong>Controller</strong> 如何接收以 <strong>GET</strong> 方式传递过来的参数</p><h3 id="1-参数直接在路径中"><a href="#1-参数直接在路径中" class="headerlink" title="1. 参数直接在路径中"></a>1. 参数直接在路径中</h3><ol><li>假设请求地址是如下这种 <strong>RESTful</strong> 风格，<strong>hangge</strong> 这个参数值直接放在路径里面：</li></ol><pre><code class="hljs java">http:<span class="hljs-comment">//localhost:8080/hello/zzl</span></code></pre><ol start="2"><li><strong>Controller</strong> 可以这么获取该参数：</li></ol><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;  <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello/&#123;name&#125;"</span>)  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"name"</span>)</span> String name) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"获取到的name是："</span> + name;  &#125;&#125;</code></pre><h3 id="2-参数直接在路径中"><a href="#2-参数直接在路径中" class="headerlink" title="2. 参数直接在路径中"></a>2. 参数直接在路径中</h3><ol><li>获取参数的基本方法</li></ol><ul><li>假设请求地址是如下这种传统方式，参数跟在问号后面：</li></ul><pre><code class="hljs java">http:<span class="hljs-comment">//localhost:8080/hello?name=zzl</span></code></pre><ul><li>Controller 可以这么获取该参数:<pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping; <span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"name"</span>)</span> String name) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"获取到的name是："</span> + name;    &#125;&#125;</code></pre></li></ul><ol start="2"><li>参数没有传递的情况</li></ol><ul><li>如果没有传递参数 Controller 将会报错，我们可以使用 required = false 标注参数是非必须的</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping; <span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@RequestParam(name = <span class="hljs-string">"name"</span>, required = <span class="hljs-keyword">false</span>)</span> String name) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"获取到的name是："</span> + name;    &#125;&#125;</code></pre><ul><li>或者可以指定个默认值，当没有传递参数时自动使用默认值：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping; <span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@RequestParam(name = <span class="hljs-string">"name"</span>, defaultValue = <span class="hljs-string">"xxx"</span>)</span> String name) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"获取到的name是："</span> + name;    &#125;&#125;</code></pre><ol start="3"><li>使用 map 来接收参数</li></ol><ul><li>Controller 还可以直接使用 map 来接收所有的请求参数：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping; <span class="hljs-keyword">import</span> java.util.Map; <span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@RequestParam Map&lt;String, Object&gt; params)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"name："</span> + params.get(<span class="hljs-string">"name"</span>) + <span class="hljs-string">"&lt;br&gt;age："</span> + params.get(<span class="hljs-string">"age"</span>);    &#125;&#125;</code></pre><ol start="4"><li>接收一个数组</li></ol><ul><li>假设请求地址是如下这种，有多个同名参数：</li></ul><pre><code class="hljs java">http:<span class="hljs-comment">//localhost:8080/hello?name=zzl&amp;name=google</span></code></pre><ul><li>我们可以定义一个数组类型的参数来接收：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping; <span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"name"</span>)</span> String[] names) </span>&#123;        String result = <span class="hljs-string">""</span>;        <span class="hljs-keyword">for</span>(String name:names)&#123;            result += name + <span class="hljs-string">"&lt;br&gt;"</span>;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><h3 id="3-使用对象来接收参数"><a href="#3-使用对象来接收参数" class="headerlink" title="3. 使用对象来接收参数"></a>3. 使用对象来接收参数</h3><ol><li>基本用法</li></ol><ul><li>如果一个 get 请求的参数太多，我们构造一个对象来简化参数的接收方式：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping; <span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(User user)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"name："</span> + user.getName() + <span class="hljs-string">"&lt;br&gt; age："</span> + user.getAge();    &#125;&#125;</code></pre><ul><li>User 类的定义如下，到时可以直接将多个参数通过 getter、setter 方法注入到对象中去：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;&#125;</code></pre><ol start="2"><li>指定参数前缀</li></ol><ul><li>如果传递的参数有前缀，且前缀与接收实体类的名称不同相，那么参数无法正常传递：</li><li>我们可以结合 @InitBinder 解决这个问题，通过参数预处理来指定使用的前缀为 u.</li></ul><p><code>除了在 Controller 里单独定义预处理方法外，我们还可以通过 @ControllerAdvice 结合 @InitBinder 来定义全局的参数预处理方法，方便各个 Controller 使用</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">import</span> org.springframework.web.bind.WebDataBinder;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*; <span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(@ModelAttribute(<span class="hljs-string">"u"</span>)</span> User user) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"name："</span> + user.getName() + <span class="hljs-string">"&lt;br&gt; age："</span> + user.getAge();    &#125;     <span class="hljs-meta">@InitBinder</span>(<span class="hljs-string">"u"</span>)    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initBinder</span><span class="hljs-params">(WebDataBinder binder)</span> </span>&#123;        binder.setFieldDefaultPrefix(<span class="hljs-string">"u."</span>);    &#125;&#125;</code></pre><ol start="3"><li>构造多个对象来接收参数</li></ol><ul><li>如果一个 get 请求的参数分属不同的对象，也可以使用多个对象来接收参数：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping; <span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(User user, Phone phone)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"name："</span> + user.getName() + <span class="hljs-string">"&lt;br&gt; age："</span> + user.getAge()                + <span class="hljs-string">"&lt;br&gt; number："</span> + phone.getNumber();    &#125;&#125;</code></pre><ul><li>新增的 Phone 类定义如下：</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;    <span class="hljs-keyword">private</span> String number;     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getNumber</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> number;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNumber</span><span class="hljs-params">(String number)</span> </span>&#123;        <span class="hljs-keyword">this</span>.number = number;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Get</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven小结</title>
    <link href="/2020/08/08/Maven/"/>
    <url>/2020/08/08/Maven/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h4 id="1-maven常用命令"><a href="#1-maven常用命令" class="headerlink" title="1. maven常用命令"></a>1. maven常用命令</h4><ul><li><p>clean：     清理</p></li><li><p>compile：编译</p></li><li><p>test：        测试</p></li><li><p>package：打包</p></li><li><p>install：    安装</p></li></ul><h4 id="2-maven的依赖范围"><a href="#2-maven的依赖范围" class="headerlink" title="2. maven的依赖范围"></a>2. maven的依赖范围</h4><table><thead><tr><th>依赖范围</th><th>对于编译classpath有效</th><th>对于测试classpath有效</th><th>对于运行时classpath有效</th><th>例子</th></tr></thead><tbody><tr><td>compile</td><td>Y</td><td>Y</td><td>Y</td><td>spring-core</td></tr><tr><td>test</td><td>-</td><td>Y</td><td>-</td><td>Junit</td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td>runtime</td><td>-</td><td>Y</td><td>Y</td><td>JDBC驱动</td></tr><tr><td>system</td><td>Y</td><td>Y</td><td>-</td><td>本地的，maven仓库之外的类库</td></tr></tbody></table><h4 id="3-maven的依赖传递"><a href="#3-maven的依赖传递" class="headerlink" title="3. maven的依赖传递"></a>3. maven的依赖传递</h4><h6 id="1-什么是依赖传递"><a href="#1-什么是依赖传递" class="headerlink" title="1. 什么是依赖传递"></a>1. 什么是依赖传递</h6><pre><code class="hljs dns">在maven中，依赖是可以传递的，假设存在三个项目，分别是项目<span class="hljs-keyword">A</span>，项目B以及项目C。假设C依赖B，B依赖<span class="hljs-keyword">A</span>，那么我们可以根据maven项目依赖的特征不难推出项目C也依赖<span class="hljs-keyword">A</span></code></pre><h6 id="2-什么是依赖冲突"><a href="#2-什么是依赖冲突" class="headerlink" title="2. 什么是依赖冲突"></a>2. 什么是依赖冲突</h6><pre><code class="hljs angelscript">由于依赖传递现象的存在， spring-webmvc 依赖 spirng-beans<span class="hljs-number">-4.2</span><span class="hljs-number">.4</span>，spring-aop 依赖 spring-beans<span class="hljs-number">-5.0</span><span class="hljs-number">.2</span>，但是发现 spirng-beans<span class="hljs-number">-4.2</span><span class="hljs-number">.4</span> 加入到了工程中，而我们希望 spring-beans<span class="hljs-number">-5.0</span><span class="hljs-number">.2</span> 加入工程。这就造成了依赖冲突</code></pre><h6 id="3-如何解决依赖冲突"><a href="#3-如何解决依赖冲突" class="headerlink" title="3. 如何解决依赖冲突"></a>3. 如何解决依赖冲突</h6><ul><li><p>使用maven提供的依赖调解原则 :</p><ul><li><p>第一声明者优先原则</p></li><li><p>路径近者优先原则</p></li></ul></li><li><p>排除依赖</p></li><li><p>锁定版本</p></li></ul><ol><li>依赖调节原则——第一声明者优先原则</li></ol><pre><code class="hljs plain">在 pom 文件中定义依赖，以先声明的依赖为准。其实就是根据坐标导入的顺序来确定最终使用哪个传递过来的依赖</code></pre><ol start="2"><li>排除依赖</li></ol><pre><code class="hljs plain">可以使用exclusions标签将传递过来的依赖排除出去</code></pre><ol start="3"><li>版本锁定</li></ol><pre><code class="hljs gradle">采用直接锁定版本的方法确定依赖jar包的版本，版本锁定后则不考虑依赖的声明顺序或依赖的路径，以锁定的版本为准添加到工程中，此方法在企业开发中经常使用。版本锁定的使用方式：第一步：在dependencyManagement标签中锁定依赖的版本第二步：在<span class="hljs-keyword">dependencies</span>标签中声明需要导入的maven坐标①在dependencyManagement标签中锁定依赖的版本②在<span class="hljs-keyword">dependencies</span>标签中声明需要导入的maven坐标</code></pre>]]></content>
    
    
    <categories>
      
      <category>小结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用PicGo + 码云 搭建属于自己的图床</title>
    <link href="/2020/05/24/PicGo/"/>
    <url>/2020/05/24/PicGo/</url>
    
    <content type="html"><![CDATA[<h1 id="使用PicGo-码云-搭建属于自己的图床"><a href="#使用PicGo-码云-搭建属于自己的图床" class="headerlink" title="使用PicGo + 码云 搭建属于自己的图床"></a>使用PicGo + 码云 搭建属于自己的图床</h1><blockquote><p>七牛云图床虽然好用但是需要以备案的域名，正在用的途中赠送的域名失效，不得已转战 <code>PicGo + 码云</code></p></blockquote><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><ul><li><p>PicGo</p><p><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo作者GitHub地址</a></p></li><li><p>picgo-plugin-gitee-uploader插件</p></li></ul><h3 id="2-插件"><a href="#2-插件" class="headerlink" title="2. 插件"></a>2. 插件</h3><p>打开PicGo，选择最底下的插件设置，搜索gitee</p><p><img src="https://gitee.com/zzl_java/PicGo/raw/master/img/20200815134254.png" srcset="/img/loading.gif" alt="image-20200815134254521"></p><p>两个其实都可以使用，这里我们安装第二个。</p><h3 id="3-建立gitee（码云）图床库"><a href="#3-建立gitee（码云）图床库" class="headerlink" title="3. 建立gitee（码云）图床库"></a>3. 建立gitee（码云）图床库</h3><h4 id="3-1-新建仓库"><a href="#3-1-新建仓库" class="headerlink" title="3.1 新建仓库"></a>3.1 新建仓库</h4><ul><li>输入一个仓库名称</li><li>其次将仓库设为公开</li><li>勾选使用Readme文件初始化这个仓库</li></ul><p><img src="https://gitee.com/zzl_java/PicGo/raw/master/img/20200815135437.png" srcset="/img/loading.gif" alt="image-20200815135437430"></p><h4 id="3-2-配置PicGo"><a href="#3-2-配置PicGo" class="headerlink" title="3.2 配置PicGo"></a>3.2 配置PicGo</h4><p>选择图床设置—&gt;gitee</p><p><img src="https://gitee.com/zzl_java/PicGo/raw/master/img/20200815134844.png" srcset="/img/loading.gif" alt="image-20200815134844543"></p><ul><li>repo：用户名/仓库名称，比如我自己的仓库zzl_java/MyPicGo，也可以直接复制仓库的url</li><li>branch：分支，这里写上master</li><li>token：填入码云的私人令牌</li><li>path：路径，一般写上img</li><li>customPath：提交消息，这一项和下一项customURL都不用填。在提交到码云后，会显示提交消息，插件默认提交的是 <code>Upload 图片名 by picGo - 时间</code></li></ul><p>这几个参数主要就是token的获取。其他的按照刚刚建的仓库填写就好。</p><h4 id="3-3-获取token"><a href="#3-3-获取token" class="headerlink" title="3.3 获取token"></a>3.3 获取token</h4><ul><li>登录进自己的码云，点击头像，进入设置</li><li>找到左面安全设置的私人令牌</li></ul><p><img src="https://gitee.com/zzl_java/PicGo/raw/master/img/20200815135306.png" srcset="/img/loading.gif" alt="image-20200815135306824"></p><ul><li>点击生成新令牌，把projects这一项勾上，其他的不用勾，然后提交</li></ul><p><img src="https://gitee.com/zzl_java/PicGo/raw/master/img/20200815135226.png" srcset="/img/loading.gif" alt="image-20200815135226150"></p><ul><li>生成令牌后把令牌复制后粘贴到token中，这个token会在离开本页的时候不再显示。然后保存设置，并把这个设置为默认图床</li></ul>]]></content>
    
    
    <categories>
      
      <category>PicGo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PicGo</tag>
      
      <tag>Gitee</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V2ray</title>
    <link href="/2020/03/25/V2ray/"/>
    <url>/2020/03/25/V2ray/</url>
    
    <content type="html"><![CDATA[<h1 id="V2ray"><a href="#V2ray" class="headerlink" title="V2ray"></a>V2ray</h1><h3 id="安装脚本"><a href="#安装脚本" class="headerlink" title="安装脚本"></a>安装脚本</h3><p><code>bash &lt;(curl -s -L https://git.io/v2ray.sh)</code><br>ubuntu/debian 系统安装 Curl 方法: <code>apt-get update -y &amp;&amp; apt-get install curl -y</code><br>centos 系统安装 Curl 方法: <code>yum update -y &amp;&amp; yum install curl -y</code><br>安装完成后，输入<code>v2ray</code> 即可管理 V2Ray</p><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><p><code>v2ray info</code> 查看 V2Ray 配置信息<br><code>v2ray config</code> 修改 V2Ray 配置<br><code>v2ray link</code> 生成 V2Ray 配置文件链接<br><code>v2ray infolink</code> 生成 V2Ray 配置信息链接<br><code>v2ray qr</code> 生成 V2Ray 配置二维码链接<br><code>v2ray ss</code> 修改 Shadowsocks 配置<br><code>v2ray ssinfo</code> 查看 Shadowsocks 配置信息<br><code>v2ray ssqr</code> 生成 Shadowsocks 配置二维码链接<br><code>v2ray status</code> 查看 V2Ray 运行状态<br><code>v2ray start</code> 启动 V2Ray<br><code>v2ray stop</code> 停止 V2Ray<br><code>v2ray restart</code> 重启 V2Ray<br><code>v2ray log</code> 查看 V2Ray 运行日志<br><code>v2ray update</code> 更新 V2Ray<br><code>v2ray update.sh</code> 更新 V2Ray 管理脚本<br><code>v2ray uninstall</code> 卸载 V2Ray</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>V2Ray 配置文件路径：<code>/etc/v2ray/config.json</code><br>Caddy 配置文件路径：<code>/etc/caddy/Caddyfile</code><br>脚本配置文件路径:<code>/etc/v2ray/233blog_v2ray_backup.conf</code></p><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p><code>V2Ray： https://www.v2ray.com/</code><br><code>233boy: https://github.com/233boy/v2ray</code></p>]]></content>
    
    
    <categories>
      
      <category>V2ray</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git小结</title>
    <link href="/2020/03/24/Git%E6%80%BB%E7%BB%93/"/>
    <url>/2020/03/24/Git%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Git学习小结"><a href="#Git学习小结" class="headerlink" title="Git学习小结"></a>Git学习小结</h1><ul><li><h3 id="本地操作流程"><a href="#本地操作流程" class="headerlink" title="本地操作流程"></a>本地操作流程</h3></li><li><p>工作区（WorkingDirectory）</p><ul><li>添加、编辑、修改文件等操作</li></ul></li><li><p>暂存区</p><ul><li>暂存已经修改的文件，最后统一提交到Git仓库 </li></ul></li><li><p>Git Repository（Git 仓库）</p><ul><li>最终确定的文件保存仓库，成为一个人新的版本，并且对他人可见</li></ul></li></ul><hr><p>常用指令 ：git add 、git commit 、git status</p><pre><code>工作区 ---git add ---&gt;  暂存区 ---git commit---&gt;Git仓库 </code></pre><hr><ul><li><h3 id="本地仓库操作"><a href="#本地仓库操作" class="headerlink" title="本地仓库操作"></a>本地仓库操作</h3></li><li><p>安装好之后进行全局配置</p><pre><code class="hljs routeros"><span class="hljs-variable">$git</span><span class="hljs-built_in"> config </span>--global user.name <span class="hljs-string">"username"</span><span class="hljs-variable">$git</span><span class="hljs-built_in"> config </span>--global user.email <span class="hljs-string">"email"</span></code></pre></li><li><p>选择文件夹进行Git初始化(告诉Git管理此目录)</p><pre><code class="hljs ebnf"><span class="hljs-attribute">git init</span></code></pre><pre><code>.git隐藏文件夹不能随意更改内容</code></pre></li><li><h5 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h5></li><li><p>git status<br>  查看当前可进行的操作</p></li><li><p>git add</p><pre><code class="hljs routeros">1.git <span class="hljs-builtin-name">add</span>  文件名2.git <span class="hljs-builtin-name">add</span>  文件名1  文件名2  文件名3  <span class="hljs-built_in">..</span>.3.git <span class="hljs-builtin-name">add</span>  .【添加当前目录到缓存区】</code></pre></li><li><p>git commit</p><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">"注释"</span></code></pre></li><li><h5 id="Git指令"><a href="#Git指令" class="headerlink" title="Git指令"></a>Git指令</h5></li><li><p>查看版本<br>  1.<code>git log</code><br>  显示Git操作日志</p><p>  2.<code>git log --pretty=oneline</code><br>  时间+操作    显示</p></li><li><p>回退操作<br>  <strong>git reset –hard 版本号</strong><br>【回到过去之后，再回到未来，则需要使用指令去查看历史操作，以得到未来的commit id】</p></li><li><p><code>git reflog</code></p></li></ul><hr><ul><li><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3></li><li><h5 id="两种常规使用方式"><a href="#两种常规使用方式" class="headerlink" title="两种常规使用方式"></a>两种常规使用方式</h5></li><li>Use HTTPS<br>  使用clone指令克隆线上仓库到本地<pre><code>`git clone 线上仓库地址`</code></pre>  在仓库上做对应的操作（提交暂存区、提交本地仓库、提交线上仓库、拉取线上仓库）<br>  提交到线上仓库指令：<code>git push</code><pre><code>首次线上仓库提交需要授权版本过低则需要修改.git目录中的config文        件，在remote中的url栗的github.com           前面加上`username:password@`</code></pre>  拉取线上仓库到本地指令：<code>git pull</code></li><li><h6 id="每天上班前第一件事-git-pull-拉取最新到本地"><a href="#每天上班前第一件事-git-pull-拉取最新到本地" class="headerlink" title="每天上班前第一件事 git pull 拉取最新到本地"></a>每天上班前第一件事 git pull 拉取最新到本地</h6></li><li><h6 id="每天下班最后一件事git-push提交最新到线上"><a href="#每天下班最后一件事git-push提交最新到线上" class="headerlink" title="每天下班最后一件事git push提交最新到线上"></a>每天下班最后一件事git push提交最新到线上</h6></li><li>Use SSH（鉴权方式不同）（比较容易）<ul><li>创建公私钥对（openssh）</li><li><code>ssh-keygen -t rsa -c &quot;email&quot;</code></li><li>三回车</li><li>上传公钥到Github</li><li>后续操作与HTTPS 相同</li></ul></li></ul><hr><ul><li><h3 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h3></li><li><p>查看分支：<code>git branch</code></p></li><li><p>创建分支：<code>git branch 分支名</code></p></li><li><p>切换分支：<code>git checkout 分支名</code></p><ul><li>对于新分支，可以使用<code>git checkout -b</code> 分支名指令来切换分支，-b表示创建并切换，相当于两个指令</li></ul></li><li><p>删除分支：<code>git branch -d 分支名</code></p></li><li><p>合并分支：<code>git merge 被合并的分支名</code></p></li><li><h3 id="冲突的产生与解决"><a href="#冲突的产生与解决" class="headerlink" title="冲突的产生与解决"></a>冲突的产生与解决</h3></li><li><p>先pull到本地</p></li><li><p>然后解决冲突</p></li><li><p>重新push</p></li><li><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>忽略文件需要新建一个名为<code>.gitignore</code>的文件，用于声明忽略文件或者不忽略文件规则，规则对当前目录及其子目录生效<br>  该文件没有文件名，只能听过命令行<code>Git bash</code>来        <code>touch</code>创建</p></li></ul><p>1.<code>/文件夹名字/</code>过滤整个文件夹<br>2.<code>*.zip</code>过滤所有.zip文件<br>3.<code>/文件夹名字/do.c</code>过滤某个具体文件<br>4.<code>!index.php</code>不过滤某个具体文件</p>]]></content>
    
    
    <categories>
      
      <category>小结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“踩坑”之旅</title>
    <link href="/2020/03/24/%E8%B8%A9%E5%9D%91/"/>
    <url>/2020/03/24/%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="“踩坑”告一段落"><a href="#“踩坑”告一段落" class="headerlink" title="“踩坑”告一段落"></a>“踩坑”告一段落</h1><ul><li>找到了喜欢的主题</li><li>踩坑也算完成吧</li><li>主题可玩性感觉还可以</li><li>修改很便捷</li><li>添加”tags“和”categories“，费了不少力气</li><li>接下来就是努力</li><li>加油！！！</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Github+HEXO (win)</title>
    <link href="/2020/03/24/github+hexo/"/>
    <url>/2020/03/24/github+hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="Github-HEXO-win"><a href="#Github-HEXO-win" class="headerlink" title="Github+HEXO (win)"></a>Github+HEXO (win)</h1><ul><li><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4></li><li><h4 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h4></li><li><h4 id="本地创建Hexo存储文件夹"><a href="#本地创建Hexo存储文件夹" class="headerlink" title="本地创建Hexo存储文件夹"></a>本地创建Hexo存储文件夹</h4></li><li><h4 id="文件夹内git-bash-here"><a href="#文件夹内git-bash-here" class="headerlink" title="文件夹内git bash here"></a>文件夹内git bash here</h4></li><li><p>可通过cmd命令移动到文件夹，也可以在文件夹地址栏直接输入cmd</p></li><li><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g hexo-cli3</code></pre></li></ul><p>安装完成，可能会有WARN，但不会影响正常使用</p><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo <span class="hljs-comment">--save</span></code></pre><p>Hexo安装完成，检测是否正确安装</p><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo -v</span></code></pre><ul><li><h4 id="Hexo的配置"><a href="#Hexo的配置" class="headerlink" title="Hexo的配置"></a>Hexo的配置</h4></li><li><p>在当前目录下新建一个名为blog的文件夹，用于存放博客网站的信息<br>命令行进入blog，初始化该文件夹，并安装所需组件</p><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">init </span><span class="hljs-attr">npm</span> <span class="hljs-string">install</span></code></pre></li><li><p>安装完成后，检测是否安装成功</p><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">g</span><span class="hljs-attr">hexo</span> <span class="hljs-string">s</span></code></pre></li><li><p>根据提示访问<a href="http://localhost:4000/(注意http不是https)" target="_blank" rel="noopener">http://localhost:4000/(注意http不是https)</a></p></li><li><h4 id="将GitHub-Page与Hexo关联"><a href="#将GitHub-Page与Hexo关联" class="headerlink" title="将GitHub Page与Hexo关联"></a>将GitHub Page与Hexo关联</h4></li><li><p>配置Git个人信息<br>这一步骤是为了以后我们用git命令提交不再需要繁琐的输入我们的Github帐号和密码。</p></li><li><p>在blog 目录下，执行下列命令配置你的用户名</p><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">"username"</span>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> <span class="hljs-string">"emailm"</span>git <span class="hljs-keyword">config</span> --list  <span class="hljs-comment">//查看用户信息</span></code></pre></li><li><p>生成秘钥</p><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">"email"</span></code></pre></li><li><p>生成文件默认路径</p><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\z</span>zl<span class="hljs-symbol">\.</span>ssh</code></pre></li><li><p>输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent</p><pre><code class="hljs bash"><span class="hljs-built_in">eval</span> <span class="hljs-string">"<span class="hljs-variable">$(ssh-agent -s)</span>"</span></code></pre></li><li><p>再次输入命令</p><pre><code class="hljs dockerfile">ssh-<span class="hljs-keyword">add</span><span class="bash"> ~/.ssh/id_rsa</span></code></pre></li><li><p>添加帐号SSH Keys<br>   登录Github，点击头像下的settings，添加ssh</p></li><li><p>输入下列命令进行验证是否成功</p><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com</code></pre></li></ul><p>接下来Hexo踩坑开始！！！</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm使用国内镜像，解决卡顿</title>
    <link href="/2020/03/24/nodejs%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/"/>
    <url>/2020/03/24/nodejs%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h1 id="npm-使用国内镜像，解决卡顿"><a href="#npm-使用国内镜像，解决卡顿" class="headerlink" title="npm 使用国内镜像，解决卡顿"></a>npm 使用国内镜像，解决卡顿</h1><ul><li>换成阿里源</li><li>git 执行<pre><code class="hljs arduino">npm <span class="hljs-built_in">config</span> <span class="hljs-built_in">set</span> registry https:<span class="hljs-comment">//registry.npm.taobao.org</span></code></pre></li><li>验证命令</li></ul><pre><code class="hljs arduino">npm <span class="hljs-built_in">config</span> <span class="hljs-built_in">get</span> registry  <span class="hljs-comment">//返回https://registry.npm.taobao.org，说明镜像配置成功。</span></code></pre><ul><li>安装cnpm<pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install -g cnpm --registry=https://registry.<span class="hljs-built_in">npm</span>.taobao.org</code></pre>OK！！！</li></ul>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Win下JDK安装及环境配置</title>
    <link href="/2020/03/24/Win%E4%B8%8BJDK%E5%AE%89%E8%A3%85/"/>
    <url>/2020/03/24/Win%E4%B8%8BJDK%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h3><ul><li>从<code>https://www.oracle.com/java/technologies/javase-jdk8-downloads.html</code>下载JDK安装包</li><li>安装下载的JDK</li></ul><h3 id="JDK环境变量配置"><a href="#JDK环境变量配置" class="headerlink" title="JDK环境变量配置"></a>JDK环境变量配置</h3><ul><li><p>环境变量配置：</p><ul><li>新建环境变量，变量名：“JAVA_HOME”，变量值：自己的JDK安装根目录（到JDK文件夹）</li></ul></li><li><p>PATH新增</p><ul><li><code>%JAVA_HOME%\bin</code></li></ul></li><li><p>JDK1.5之后不必配置CLASS_PATH，因为：在java1.5之后，把当前目录（运行 java.class 时所在目录）当做了classpath路径，而编译后的.class文件和.java文件在同一目录下，所以不需要配置</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Win</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
